#!/usr/bin/env python3
"""
ReDoS regex attack string generate tool - Regexploit
Entry point script that follows the project contract.
"""

import sys
import json
import time
import base64
import traceback
import re
from pathlib import Path

# Add the source directory to the path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from regexploit.ast.sre import SreOpParser
from regexploit.redos import find

def main():
    if len(sys.argv) != 3:
        print("Usage: python run.py <base64_regex> <output_file_path>", file=sys.stderr)
        sys.exit(1)
    
    base64_regex = sys.argv[1]
    output_file_path = sys.argv[2]
    
    try:
        # Decode the base64 regex
        regex_bytes = base64.b64decode(base64_regex)
        regex_pattern = regex_bytes.decode('utf-8')
        
        # Record start time
        start_time = time.time()
        
        # Parse and analyze the regex
        output_json = analyze_regex(regex_pattern)
        
        # Record end time
        end_time = time.time()
        elapsed_ms = int((end_time - start_time) * 1000)
        output_json["elapsed_ms"] = elapsed_ms
        
        # Write output to file
        with open(output_file_path, 'w') as f:
            json.dump(output_json, f, indent=2)
            
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        # In case of error, return a safe default
        output_json = {
            "elapsed_ms": 0,
            "is_redos": False
        }
        with open(output_file_path, 'w') as f:
            json.dump(output_json, f, indent=2)

def analyze_regex(pattern):
    """Analyze a regex pattern for ReDoS vulnerabilities"""
    
    # Default output
    output = {
        "elapsed_ms": 0,  # Will be set by main()
        "is_redos": False
    }
    
    try:
        # Parse the regex using SreOpParser
        parser = SreOpParser()
        parsed = parser.parse_sre(pattern, 0)
        
        # Find ReDoS vulnerabilities
        redos_list = find(parsed)
        
        # Check if any ReDoS found with starriness > 2 (cubic or higher complexity)
        for redos in redos_list:
            if redos.starriness > 2:
                output["is_redos"] = True
                
                # Generate attack string components
                prefix = redos.example_prefix
                
                # Get the repeated character
                repeated_char = redos.repeated_character.example()
                
                # Create suffix (killer character if exists)
                suffix = ""
                if redos.killer:
                    suffix = redos.killer.example()
                
                # Encode components as base64
                output.update({
                    "prefix": base64.b64encode(prefix.encode('utf-8')).decode('utf-8'),
                    "infix": base64.b64encode(repeated_char.encode('utf-8')).decode('utf-8'),
                    "suffix": base64.b64encode(suffix.encode('utf-8')).decode('utf-8'),
                    "repeat_times": 3456  # Standard repeat count used by regexploit
                })
                break  # Use the first (most severe) ReDoS found
    
    except Exception as e:
        # If parsing fails, assume not ReDoS
        print(f"Analysis error: {e}", file=sys.stderr)
        output["is_redos"] = False
        output["error"] = str(e)
    
    return output

if __name__ == "__main__":
    main() 